---
title: "Primary school temporal network"
author: "Vlasenko Daniil"
date: "2023-06-19"
output: 
  html_document:
    toc: true
    toc_float: true
---

## Данные 

Данные взяты c [этого сайта](http://www.sociopatterns.org/datasets/primary-school-temporal-network-data). Данные описывают взаимодействия учеников и учителей начальной школы в течении недели. У каждого участника эксперемента при себе было устройство, которое фиксировало каждые 20 секунд, с кем он сейчас контактирует.

Через анализ этих данных я хочу изучить на практике теорию, изложенную в книги [Network science](http://networksciencebook.com/) и познакомиться с вариантом библиотеки igraph для языка R.

Подключаем необходимые билиотеки:
```{r, message=FALSE}
library(dplyr)
library(igraph)
library(tidyr)
library(RColorBrewer)
```

Читаем данные:
```{r}
data1 <- read.csv("primaryschool.csv", sep="\t", header=FALSE)
colnames(data1) <- c("time", "i", "j", "classi", "classj")
data2 <- read.csv("metadata_primaryschool.txt", sep="\t", header=FALSE)
colnames(data2) <- c("i", "class", "sex")
```

data1 содержит информацию о том, когда (time) кто с кем (i, j) контактировал и из какого они класса или являются ли учителем (Ci, Cj). data2 содержит дополнительную информаицю о поле учеников. 

Хотим работать с взыешенным графом, поэтому посчитаем для каждой пары индивидов (ученик или учитель) число контактов (Freq) и затем удалим из данных пары индивидов, которые не контактировали друг с другом.
```{r}
edges <- data.frame(table(data1 %>% dplyr::select(i, j))) %>%
  filter(Freq > 0)
```

Создадим взвешенный неориентированный граф:
```{r}
network <- graph_from_data_frame(edges, directed=FALSE, vertices=data2)
```

## Визуализация

Визуализируем сеть:
```{r}
set.seed(1)
pal<-brewer.pal(length(unique(V(network)$class)), "Set3")

plot(network, edge.color='black', vertex.label.cex=0.00001,
     vertex.color=pal[as.numeric(as.factor(vertex_attr(network, "class")))],
     vertex.size=sqrt(V(network)$degree)/2.5, edge.width=sqrt(E(network)$Freq/3000),
     layout=layout.fruchterman.reingold)
```

Добавим к визуализации кластеризацию основанную на методе Лувена:
```{r}
lc <- cluster_louvain(network) 
#2. Plotting the Betweenness Centrality network with the community detection

set.seed(1001) # To duplicate the computer process and create exactly the same network repetitively you should set the seed.
plot(lc, network, edge.color = 'black', vertex.label.cex=0.00001,
     vertex.color=pal[as.numeric(as.factor(vertex_attr(network, "class")))],
     vertex.size=sqrt(V(network)$degree)/2.5, edge.width=sqrt(E(network)$Freq/3000),
     layout=layout.fruchterman.reingold)
```


## Анализ 

Проверим данные графа:
```{r}
network
```

Видно, что граф имеет 242 вершины и 8317 ребер.

В исходных данных нет информации о поле некоторых индивидов. Таким образом у вершин графа атрибут sex содержит значения "Unknown" заменим это значение на NA:
```{r}
V(network)$sex[V(network)$sex == "Unknown"] <- NA
V(network)$sex[1:50]
```

Также вершины графа несут информацию о классе ученика или о том, что эта вершина связана с учителем:
```{r}
V(network)$class[1:50]
```

У ребер в графе есть веса:
```{r}
E(network)$Freq[1:50]
```

### Распределение степеней вершин

Добавим к вершинами атрибут degree, который будет отражать степень вершины:
```{r}
V(network)$degree <- degree(network)
V(network)$degree[1:50]
```

Посчитаем некоторые характеристики распределения степеней:
```{r}
data.v <- V(network)
data.v
print(paste("Mean of sample:", mean(V(network)$degree)))
print(paste("Variance of sample:", var(V(network)$degree)))
print(paste("Median of sample:", median(V(network)$degree)))
print(paste("Min of sample:", min(V(network)$degree)))
print(paste("Max of sample:", max(V(network)$degree)))
```

Изобразим распределение степеней:
```{r, message=FALSE}
library(ggplot2)

data.v <- data.frame(name=V(network)$name, 
                     class=as.factor(V(network)$class),
                     degree=V(network)$degree)

data.v %>%
  ggplot(aes(x=degree)) +
  geom_histogram(aes(y=..density..))
```

Немного похоже на нормальное, проверим это. Критерий Пирсона делит распределение на состояния, чтобы правильное его дискретизировать. Критерий Лиллиефорса - это модификация критерия Колмогорова-Смирнова для проверки сложных гипотез. Критерий Андерона-Дарлинга - это один из критериев типа w^2. Критерий Шапира-Уилка - примерно квадрат корреляции между x и y в n.p.p.
```{r}
library(nortest)

print(paste("Pearson", pearson.test(data.v$degree)$p))
print(paste("Lilliefors", lillie.test(data.v$degree)$p))
print(paste("Anderson.Darling", ad.test(data.v$degree)$p))
print(paste("Shapiro.Wilk", shapiro.test(data.v$degree)$p))
```

Критерий Лилифорса с уровнем значимости 0.5 не отверг гипотезу о нормальности, остальные отвергли.

Найдем топ 10 центральныйх вершин, основываясь на степенях. Я предпологаю, что самыми социальными являются учителя. 
```{r}
count.of.teachers <- data.v %>% filter(class == "Teachers") %>% nrow()
(data.v %>% arrange(-degree))[1:count.of.teachers,]
```

Нет, оказалось, что это не так. 

### Плотность сети
Вычислим плотность сети:
```{r}
edge_density(network)
```

Вычилим плотности подсетей для кажого класса, они должны быть больше:
```{r}
class <- unique(V(network)$class)

for(i in class) {
  subgraph <- induced_subgraph(network, V(network)[class == i])
  print(paste("density of", i, ":", edge_density(subgraph)))
}
```

Так и выходит, логично, что дети внутри класса контактируют друг с другом больше.

Изобразим матрицу сопряженности для всей сети, чем темнее точка тем выше степень взаимодействия двух участников эксперемента:
```{r, message=FALSE, warning=FALSE}
data.e <- as_long_data_frame(network) %>% 
  mutate(from = as.character(from), to = as.character(to))

tmp <- data.frame(to = data.e$from, from = data.e$to, Freq = data.e$Freq, 
                 to_class = data.e$from_class, from_class = data.e$to_class)

tmp <- rbind(data.e %>% select(from, to, Freq, to_class, from_class), tmp)

tmp %>%
  ggplot(aes(from, to)) +
  geom_raster(aes(fill=Freq)) +
  scale_fill_gradient2(low="gray100", mid="gray50", high="gray0") +
  theme(legend.position="none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background = element_blank())
```

Матрица сопряженности демонстрирует плотнсоть сети, отстутсвие точки означает, что два индивида не взаимодействовали. Изобразим матрицу сопряженности для одного класса, например, 4B:
```{r}
tmp %>% filter(from_class == "4B", to_class == "4B") %>%
  ggplot(aes(from, to)) +
  geom_raster(aes(fill=Freq)) +
  scale_fill_gradient2(low="gray100", mid="gray50", high="gray0") +
  theme(legend.position="none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background = element_blank())
```

Можно видеть, что матрица сопряженности намного плотнее для конкретного класса.

### Кратчайший путь.

Посчитаем среднее расстояние между индивидами в сети.
```{r}
mean_distance(network)
```

В принципе ожидать, что в школе, где есть учителя, через которые связанны все классы,
будут длинные пути неправильно. Найдем максимальную длину:
```{r}
max(distances(network))
```

### Коэффициент кластеризации
Посчитаем коэффициенты кластеризации (вероятность того, что смежные вершины будутсвязаны) для всей сети:
```{r}
transitivity(network)
```

Посчитаем коэффициенты кластеризации для каждой вершины:
```{r}
V(network)$transitivity <- transitivity(network, type="local")
V(network)$transitivity[1:50]
data.v$transitivity <- V(network)$transitivity
```

Првоерим топ 10 индивидов с наибольшим коэффициентом кластеризации:
```{r}
(data.v %>% arrange(-transitivity))[1:10,]
```

Это ученики с небольшими степенями.





