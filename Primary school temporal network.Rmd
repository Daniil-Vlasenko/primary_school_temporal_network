---
title: "Primary school temporal network"
author: "Власенко Даниил"
date: "2023-06-19"
output: 
  html_document:
    toc: true
    toc_float: true
---

## Данные 

Данные взяты c [этого сайта](http://www.sociopatterns.org/datasets/primary-school-temporal-network-data). Данные описывают взаимодействия учеников и учителей начальной школы в течении недели. У каждого участника эксперимента при себе было устройство, которое фиксировало каждые 20 секунд, с кем он сейчас контактирует.

Через анализ этих данных я хочу изучить на практике теорию, изложенную в книгах [Network Science](http://networksciencebook.com/) и [Statistical Analysis of Network Data with R](https://link.springer.com/book/10.1007/978-1-4939-0983-4), и познакомиться с вариантом библиотеки igraph для языка R.

Подключаем необходимые библиотеки:
```{r, message=FALSE}
library(dplyr)
library(igraph)
library(tidyr)
```

Читаем данные:
```{r}
data1 <- read.csv("primaryschool.csv", sep="\t", header=FALSE)
colnames(data1) <- c("time", "i", "j", "classi", "classj")
data2 <- read.csv("metadata_primaryschool.txt", sep="\t", header=FALSE)
colnames(data2) <- c("i", "class", "sex")
```

data1 содержит информацию о том, когда (time) кто с кем (i, j) контактировал и из какого они класса или являются ли учителем (classi, classj). data2 содержит дополнительную информацию о поле учеников. 

Хотим работать с взвешенным графом, поэтому посчитаем для каждой пары индивидов (ученик или учитель) число контактов (Freq) и затем удалим из данных пары индивидов, которые не контактировали друг с другом.
```{r}
data1 <- data.frame(table(data1 %>% dplyr::select(i, j))) %>%
  filter(Freq > 0)
```

Создадим взвешенный неориентированный граф:
```{r}
network <- graph_from_data_frame(data1, directed=FALSE, vertices=data2)
```

## Анализ 

Проверим данные графа:
```{r}
network
```

Видно, что граф имеет 242 вершины и 8317 ребер.

В исходных данных нет информации о поле некоторых индивидов. Таким образом у вершин графа атрибут sex содержит значения "Unknown" заменим это значение на NA:
```{r}
V(network)$sex[V(network)$sex == "Unknown"] <- NA
V(network)$sex[1:50]
```

Также вершины графа несут информацию о классе ученика или о том, что эта вершина есть учитель:
```{r}
V(network)$class[1:50]
```

У ребер в графе есть веса:
```{r}
E(network)$Freq[1:50]
```

### Общие характеристики

Проверим, является ли граф связным:
```{r}
is_connected(network)
```

### Распределение степеней вершин

Добавим к вершинами атрибут degree, который будет отражать степень вершины:
```{r}
V(network)$degree <- degree(network)
V(network)$degree[1:50]
```

Посчитаем некоторые характеристики распределения степеней:
```{r}
print(paste("Mean of sample:", mean(V(network)$degree)))
print(paste("Variance of sample:", var(V(network)$degree)))
print(paste("Median of sample:", median(V(network)$degree)))
print(paste("Min of sample:", min(V(network)$degree)))
print(paste("Max of sample:", max(V(network)$degree)))
```

Изобразим распределение степеней:
```{r, message=FALSE}
library(ggplot2)

vertices <- igraph::as_data_frame(network, what="vertices")

vertices %>%
  ggplot(aes(x=degree)) +
  geom_histogram(aes(y=..density..))
```

Немного похоже на нормальное, проверим это. Критерий Пирсона делит распределение на состояния, чтобы правильное его дискретизировать. Критерий Лиллиефорса - это модификация критерия Колмогорова-Смирнова для проверки сложных гипотез. Критерий Андерона-Дарлинга - это один из критериев типа w^2. Критерий Шапира-Уилка - примерно квадрат корреляции между x и y в n.p.p.
```{r}
library(nortest)

print(paste("Pearson", pearson.test(vertices$degree)$p))
print(paste("Lilliefors", lillie.test(vertices$degree)$p))
print(paste("Anderson.Darling", ad.test(vertices$degree)$p))
print(paste("Shapiro.Wilk", shapiro.test(vertices$degree)$p))
```

Критерий Лилифорса с уровнем значимости 0.5 не отверг гипотезу о нормальности, остальные отвергли.

Найдем топ 10 центральныйх вершин, основываясь на степенях. Я предпологаю, что самыми социальными являются учителя. 
```{r}
count.of.teachers <- vertices %>% filter(class == "Teachers") %>% nrow()
(vertices %>% arrange(-degree))[1:count.of.teachers,]
```

Нет, оказалось, что это не так. 

### Плотность сети
Вычислим плотность сети:
```{r}
edge_density(network)
```

Вычилим плотности подсетей для кажого класса, они должны быть больше:
```{r}
class <- unique(V(network)$class)

for(i in class) {
  subgraph <- induced_subgraph(network, V(network)[class == i])
  print(paste("density of", i, ":", edge_density(subgraph)))
}
```

Так и выходит, логично, что дети внутри класса контактируют друг с другом больше.

Изобразим матрицу сопряженности для всей сети, чем темнее точка тем выше степень взаимодействия двух участников эксперимента:
```{r, message=FALSE, warning=FALSE}
edges <- as_long_data_frame(network) %>% 
  mutate(from = as.character(from), to = as.character(to))

tmp <- data.frame(to = edges$from, from = edges$to, Freq = edges$Freq, 
                 to_class = edges$from_class, from_class = edges$to_class)

tmp <- rbind(edges %>% select(from, to, Freq, to_class, from_class), tmp)

tmp %>%
  ggplot(aes(from, to)) +
  geom_raster(aes(fill=Freq)) +
  scale_fill_gradient2(low="gray100", mid="gray50", high="gray0") +
  theme(legend.position="none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background = element_blank())
```

Матрица сопряженности демонстрирует плотнсоть сети, отстутсвие точки означает, что два индивида не взаимодействовали. Изобразим матрицу сопряженности для одного класса, например, 4B:
```{r}
tmp %>% filter(from_class == "4B", to_class == "4B") %>%
  ggplot(aes(from, to)) +
  geom_raster(aes(fill=Freq)) +
  scale_fill_gradient2(low="gray100", mid="gray50", high="gray0") +
  theme(legend.position="none") +
  theme(axis.title.x=element_blank(),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        panel.background = element_blank())
```

Можно видеть, что матрица сопряженности намного плотнее для конкретного класса.

### Длины путей.

Посчитаем среднее расстояние между индивидами в сети.
```{r}
mean_distance(network)
```

В принципе ожидать, что в школе, где есть учителя, через которые связанны все классы,
будут длинные пути неправильно. Найдем максимальную длину:
```{r}
max(distances(network))
```

### Коэффициент кластеризации
Посчитаем коэффициенты кластеризации для всей сети (вероятность того, что смежные для случайной вершины вершины будут связаны):
```{r}
transitivity(network)
```

Посчитаем коэффициенты кластеризации для каждой вершины:
```{r}
V(network)$transitivity <- transitivity(network, type="local")
V(network)$transitivity[1:50]
vertices$transitivity <- V(network)$transitivity
```

Првоерим топ 10 индивидов с наибольшим коэффициентом кластеризации:
```{r}
(vertices %>% arrange(-transitivity))[1:10,]
```

Это ученики с небольшими степенями.

### Корреляция степеней вершин
Изобразим матрицу корреляций степеней вершин, ячейка (i, j) которой демонстрирует вероятность
связи вершин со степенями i и j:
```{r, message=FALSE, warning=FALSE}
library(reshape)

data.prob <- edges %>% 
  dplyr::select(from_degree, to_degree) %>% 
  table() %>% 
  data.frame() %>%
  mutate(Freq = Freq / sum(Freq)) %>%
  dplyr::rename(probability = Freq) %>%
  filter(probability > 0)

tmp <- data.frame(from_degree = data.prob$to_degree, 
                  to_degree = data.prob$from_degree,
                  probability = data.prob$probability)

tmp <- rbind(data.prob, tmp)

tmp %>%
  ggplot(aes(from_degree, to_degree)) +
    geom_raster(aes(fill = probability)) +
    scale_fill_gradient2(low="gray100", mid="gray50", high="gray0") +
    scale_x_discrete(breaks=seq(20, 134, 5)) +
    scale_y_discrete(breaks=seq(20, 134, 5)) +
    theme(panel.background = element_blank())
```

Посчитаем корреляции Пирсона и Спирмана для степеней вершин:
```{r}
# cor(data.prob$from_degree, data.prob$to_degree, method="pearson")
# cor(data.prob$from_degree, data.prob$to_degree, method="spearman")
```


### Анализ соседей учителей
Зная, что в школах России у начальных классов есть по одному главному 
учителю, который преподает почти все дисциплины, интересно проверить будем ли
мы наблюдать ту же картину в западной школе. Посчитаем соседей для каждого учителя
в каждом классе:
```{r}
for(i in V(network)[class == "Teachers"]) {
  print(paste0("neighbors of the teacher with id ", i, ":"))
  print(table(neighbors(network, i)$class))
}
```
Видно, что чаше у одного учителя подавляюще много контактов с учениками одного класса,
но также встречаются учителя, которые активно контактируют с учениками двух классов.

## Визуализация

Протестируем разные способы визуализации сети. 

Начнем с круговой визуализации. Так как в сети много вершин, то визуализация всех данных
через круг приведет к тому, что на ней будет ничего не видно. Но визуализировать отдельный 
класс не имеет смысла, так как получится почти полный граф. Посмотрим как 
выглядят связи для топ 30 учеников с наименьшими степенями свободы.
```{r}
set.seed(0)

igraph_options(vertex.size=8, 
               vertex.label.cex=0.5, 
               vertex.label.dist=1.5, 
               vertex.label.degree=3*pi/2,
               edge.width=1)
subnetwork <- subgraph(network, (vertices %>% filter(class != "Teachers") %>%
                                   arrange(degree))[1:30,]$name)
plot(subnetwork, layout=layout_in_circle)
```

Продолжим работать с той же выборкой учеников. Попробуем разные методы 
визуализации, позже визуализируем всю сеть. Сеть:
```{r}
plot(subnetwork, layout=layout_on_grid)
```

Сфера:
```{r}
plot(subnetwork, layout=layout_on_sphere)
```

Случайное расположение вершин:
```{r}
plot(subnetwork, layout=layout_randomly)
```

Алгоритм Дэвидсона и Харела:
```{r}
plot(subnetwork, layout=layout_with_dh)
```

Алгоритм Фрухтермана и Рейнгольда:
```{r}
plot(subnetwork, layout=layout_with_fr)
```

Сигма алгоритм:
```{r}
plot(subnetwork, layout=layout_with_sugiyama)
```

В общем, в igraph есть много разных методов отрисовки графов, не будем все тестировать. 


```{r}
library(igraphdata)
data(karate)
# Reproducible layout
set.seed(42)
l <- layout_with_kk(karate)
# Plot undecorated first.
igraph_options(vertex.size=10)
par(mfrow=c(1,1))
plot(karate, layout=l, vertex.label=V(karate), 
     vertex.color=NA)
# Now decorate, starting with labels.
V(karate)$label <- sub("Actor ", "", V(karate)$name)
# Two leaders get shapes different from club members.
V(karate)$shape <- "circle"
V(karate)[c("Mr Hi", "John A")]$shape <- "rectangle"
# Differentiate two factions by color.
V(karate)[Faction == 1]$color <- "red"
V(karate)[Faction == 2]$color <- "dodgerblue"
# Vertex area proportional to vertex strength
# (i.e., total weight of incident edges).
V(karate)$size <- 4*sqrt(strength(karate))
V(karate)$size2 <- V(karate)$size * .5
# Weight edges by number of common activities
E(karate)$width <- E(karate)$weight
# Color edges by within/between faction.
F1 <- V(karate)[Faction==1]
F2 <- V(karate)[Faction==2]
E(karate)[ F1 %--% F1 ]$color <- "pink"
E(karate)[ F2 %--% F2 ]$color <- "lightblue"
E(karate)[ F1 %--% F2 ]$color <- "yellow"
# Offset vertex labels for smaller points (default=0).
V(karate)$label.dist <- 
  ifelse(V(karate)$size >= 9.0, 0, 1.0)
# Plot decorated graph, using same layout.
png(file="saving_plot2.png",
    width=600, height=350)
plot(karate, layout=l)
dev.off()

E(karate)[ F1 %--% F1 ]
```

Перейдем к визуализации всей сети, каждый класс будем окрашивать в свой цвет:

```{r}
V(network)$label <- V(network)$name

V(network)$shape <- "circle"
V(network)[class=="Teachers"]$shape <- "rectangle"

unique(V(network)$class)

V(network)[class == "Teachers"]$color <- "white"
V(network)[class == "5B"]$color <- "antiquewhite2"
V(network)[class == "5A"]$color <- "aquamarine2"
V(network)[class == "4A"]$color <- "blueviolet"
V(network)[class == "3B"]$color <- "coral3"
V(network)[class == "4B"]$color <- "cadetblue1"
V(network)[class == "2A"]$color <- "chartreuse3"
V(network)[class == "1B"]$color <- "chocolate2"
V(network)[class == "2B"]$color <- "darkgoldenrod3"
V(network)[class == "1A"]$color <- "darkgrey"
V(network)[class == "3A"]$color <- "deeppink3"

set.seed(1)
plot(network, 
     vertex.size=sqrt(V(network)$degree)/2.5, 
     edge.width=sqrt(E(network)$Freq/3000),
     vertex.label.cex=0.00001,
     layout=layout_with_fr)
```


```{r}
library(RColorBrewer)

set.seed(1)
pal<-brewer.pal(length(unique(V(network)$class)), "Set3")

plot(network, edge.color='black', vertex.label.cex=0.00001,
     vertex.color=pal[as.numeric(as.factor(vertex_attr(network, "class")))],
     vertex.size=sqrt(V(network)$degree)/2.5, edge.width=sqrt(E(network)$Freq/3000),
     layout=layout_with_fr)
```

Здесь каждый класс имеет свой цвет.

Добавим к визуализации кластеризацию, основанную на методе Лувена:
```{r}
set.seed(1001) 
lc <- cluster_louvain(network) 

plot(lc, network, edge.color = 'black', vertex.label.cex=0.00001,
     vertex.color=pal[as.numeric(as.factor(vertex_attr(network, "class")))],
     vertex.size=sqrt(V(network)$degree)/2.5, edge.width=sqrt(E(network)$Freq/3000),
     layout=layout_with_fr)
```



```{r}

```

